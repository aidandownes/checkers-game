{"version":3,"sources":["node_modules/browser-pack/_prelude.js","scripts/js/app.js","scripts/js/checkers-bitboard.js","scripts/js/checkers-board.js","scripts/js/checkers-game-menu.js","scripts/js/checkers-game-stats.js","scripts/js/checkers-module.js","scripts/js/checkers-service.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","\"use strict\";\nconst checkers_module_1 = require('./checkers-module');\nexports.AppModule = angular.module('app', [checkers_module_1.CheckersModule.name, 'ngMaterial']);\n","\"use strict\";\nconst S = (function () {\n    let squares = [];\n    for (let i = 0; i < 32; i++) {\n        squares.push(1 << i);\n    }\n    return squares;\n})();\nconst MASK_L3 = S[1] | S[2] | S[3] | S[9] | S[10] | S[11] | S[17] | S[18] | S[19] | S[25] | S[26] | S[27];\nconst MASK_L5 = S[4] | S[5] | S[6] | S[12] | S[13] | S[14] | S[20] | S[21] | S[22];\nconst MASK_R3 = S[28] | S[29] | S[30] | S[20] | S[21] | S[22] | S[12] | S[13] | S[14] | S[4] | S[5] | S[6];\nconst MASK_R5 = S[25] | S[26] | S[27] | S[17] | S[18] | S[19] | S[9] | S[10] | S[11];\n(function (Player) {\n    Player[Player[\"None\"] = 0] = \"None\";\n    Player[Player[\"White\"] = 1] = \"White\";\n    Player[Player[\"Black\"] = 2] = \"Black\";\n})(exports.Player || (exports.Player = {}));\nvar Player = exports.Player;\nexports.SQUARE_COUNT = 32;\nclass Bitboard {\n    constructor(whitePieces = 0xFFF00000, blackPieces = 0x00000FFF, kings = 0, player = Player.White) {\n        this.whitePieces = whitePieces;\n        this.blackPieces = blackPieces;\n        this.kings = kings;\n        this.player = player;\n        if (this.player == Player.White) {\n            let canPlay = this.getJumpersWhite() || this.getSteppersWhite();\n            this.winner = canPlay ? Player.None : Player.Black;\n        }\n        else {\n            let canPlay = this.getJumpersBlack() || this.getSteppersBlack();\n            this.winner = canPlay ? Player.None : Player.White;\n        }\n    }\n    getPlayerAtSquare(square) {\n        const mask = S[square];\n        if (this.whitePieces & mask) {\n            return Player.White;\n        }\n        else if (this.blackPieces & mask) {\n            return Player.Black;\n        }\n        else {\n            return Player.None;\n        }\n    }\n    getSteppersWhite() {\n        if (this.player != Player.White) {\n            return 0;\n        }\n        const notOccupied = ~(this.whitePieces | this.blackPieces);\n        const kingPieces = this.whitePieces & this.kings;\n        let movers = (notOccupied << 4) & this.whitePieces;\n        movers |= ((notOccupied & MASK_L3) << 3) & this.whitePieces;\n        movers |= ((notOccupied & MASK_L5) << 5) & this.whitePieces;\n        if (kingPieces) {\n            movers |= (notOccupied >> 4) & kingPieces;\n            movers |= ((notOccupied & MASK_R3) >> 3) & kingPieces;\n            movers |= ((notOccupied & MASK_R5) >> 5) & kingPieces;\n        }\n        return movers;\n    }\n    getSteppersBlack() {\n        if (this.player != Player.Black) {\n            return 0;\n        }\n        const notOccupied = ~(this.whitePieces | this.blackPieces);\n        const kingPieces = this.blackPieces & this.kings;\n        let movers = (notOccupied >> 4) & this.blackPieces;\n        movers |= ((notOccupied & MASK_R3) >> 3) & this.blackPieces;\n        movers |= ((notOccupied & MASK_R5) >> 5) & this.blackPieces;\n        if (kingPieces) {\n            movers |= (notOccupied >> 4) & kingPieces;\n            movers |= ((notOccupied & MASK_L3) << 3) & kingPieces;\n            movers |= ((notOccupied & MASK_L5) << 5) & kingPieces;\n        }\n        return movers;\n    }\n    getJumpersWhite(whitePieces, blackPieces, kings) {\n        whitePieces = whitePieces || this.whitePieces;\n        blackPieces = blackPieces || this.blackPieces;\n        kings = kings || this.kings;\n        const notOccupied = ~(whitePieces | blackPieces);\n        const kingPieces = whitePieces & kings;\n        let movers = 0;\n        let temp = (notOccupied << 4) & blackPieces;\n        movers |= (((temp & MASK_L3) << 3) | ((temp & MASK_L5) << 5)) & whitePieces;\n        temp = (((notOccupied & MASK_L3) << 3) | ((notOccupied & MASK_L5) << 5)) & blackPieces;\n        movers |= (temp << 4) & whitePieces;\n        if (kingPieces) {\n            temp = (notOccupied >> 4) & blackPieces;\n            movers |= (((temp & MASK_R3) >> 3) | ((temp & MASK_R5) >> 5)) & kingPieces;\n            temp = (((notOccupied & MASK_R3) >> 3) | ((notOccupied & MASK_R5) >> 5)) & blackPieces;\n            movers |= (temp >> 4) & kingPieces;\n        }\n        return movers;\n    }\n    getJumpersBlack(whitePieces, blackPieces, kings) {\n        whitePieces = whitePieces || this.whitePieces;\n        blackPieces = blackPieces || this.blackPieces;\n        kings = kings || this.kings;\n        const notOccupied = ~(whitePieces | blackPieces);\n        const kingPieces = blackPieces & kings;\n        let movers = 0;\n        let temp = (notOccupied >> 4) & whitePieces;\n        movers |= (((temp & MASK_R3) >> 3) | ((temp & MASK_R5) >> 5)) & blackPieces;\n        temp = (((notOccupied & MASK_R3) >> 3) | ((notOccupied & MASK_R5) >> 5)) & whitePieces;\n        movers |= (temp >> 4) & blackPieces;\n        if (kingPieces) {\n            temp = (notOccupied << 4) & whitePieces;\n            movers |= (((temp & MASK_L3) << 3) | ((temp & MASK_L5) << 5)) & kingPieces;\n            temp = (((notOccupied & MASK_L3) << 3) | ((notOccupied & MASK_L5) << 5)) & whitePieces;\n            movers |= (temp << 4) & kingPieces;\n        }\n        return movers;\n    }\n    tryStep(source, destination) {\n        let sourceMask = S[source];\n        let destinationMask = S[destination];\n        let isKing = sourceMask & this.kings;\n        if (this.player == Player.White) {\n            let canMove = (destinationMask << 4) & sourceMask;\n            canMove |= ((destinationMask & MASK_L3) << 3) & sourceMask;\n            canMove |= ((destinationMask & MASK_L5) << 5) & sourceMask;\n            if (isKing) {\n                canMove |= (destinationMask >> 4) & sourceMask;\n                canMove |= ((destinationMask & MASK_R3) >> 3) & sourceMask;\n                canMove |= ((destinationMask & MASK_R5) >> 5) & sourceMask;\n            }\n            if (canMove) {\n                let whitePieces = (this.whitePieces | destinationMask) ^ sourceMask;\n                let blackPieces = this.blackPieces;\n                let kings = isKing ? (this.kings | destinationMask) ^ sourceMask : this.kings | (destinationMask & 0xF);\n                let player = Player.Black;\n                return {\n                    success: true,\n                    board: new Bitboard(whitePieces, blackPieces, kings, player)\n                };\n            }\n        }\n        else if (this.player = Player.Black) {\n            let canMove = (destinationMask >> 4) & sourceMask;\n            canMove |= ((destinationMask & MASK_R3) >> 3) & sourceMask;\n            canMove |= ((destinationMask & MASK_R5) >> 5) & sourceMask;\n            if (isKing) {\n                canMove |= (destinationMask << 4) & sourceMask;\n                canMove |= ((destinationMask & MASK_L3) << 3) & sourceMask;\n                canMove |= ((destinationMask & MASK_L5) << 5) & sourceMask;\n            }\n            if (canMove) {\n                let whitePieces = this.whitePieces;\n                let blackPieces = (this.blackPieces | destinationMask) ^ sourceMask;\n                let kings = this.kings | (destinationMask & 0xF0000000);\n                let player = Player.White;\n                return {\n                    success: true,\n                    board: new Bitboard(whitePieces, blackPieces, kings, player)\n                };\n            }\n        }\n        return { success: false };\n    }\n    tryJump(source, destination) {\n        let sourceMask = S[source];\n        let destinationMask = S[destination];\n        let isKing = sourceMask & this.kings;\n        if (this.player == Player.White) {\n            let canJump;\n            let temp = (destinationMask << 4) & this.blackPieces;\n            canJump = (((temp & MASK_L3) << 3) | ((temp & MASK_L5) << 5)) & sourceMask;\n            if (!canJump) {\n                temp = (((destinationMask & MASK_L3) << 3) | ((destinationMask & MASK_L5) << 5)) & this.blackPieces;\n                canJump = (temp << 4) & sourceMask;\n            }\n            if (!canJump && isKing) {\n                temp = (destinationMask >> 4) & this.blackPieces;\n                canJump = (((temp & MASK_R3) >> 3) | ((temp & MASK_R5) >> 5)) & sourceMask;\n            }\n            if (!canJump && isKing) {\n                temp = (((destinationMask & MASK_R3) >> 3) | ((destinationMask & MASK_R5) >> 5)) & this.blackPieces;\n                canJump = (temp << 4) & sourceMask;\n            }\n            if (canJump) {\n                let whitePieces = (this.whitePieces | destinationMask) ^ sourceMask;\n                let blackPieces = this.blackPieces ^ temp;\n                let kings = this.kings | (destinationMask & 0xF);\n                let canJumpAgain = (kings == this.kings) &&\n                    (this.getJumpersWhite(whitePieces, blackPieces, kings) & destinationMask);\n                let player = canJumpAgain ? Player.White : Player.Black;\n                return {\n                    success: true,\n                    board: new Bitboard(whitePieces, blackPieces, kings, player)\n                };\n            }\n        }\n        else if (this.player == Player.Black) {\n            let canJump;\n            let temp = (destinationMask >> 4) & this.whitePieces;\n            canJump = (((temp & MASK_R3) >> 3) | ((temp & MASK_R5) >> 5)) & sourceMask;\n            if (!canJump) {\n                temp = (((destinationMask & MASK_R3) >> 3) | ((destinationMask & MASK_R5) >> 5)) & this.whitePieces;\n                canJump = (temp >> 4) & sourceMask;\n            }\n            if (!canJump && isKing) {\n                temp = (destinationMask << 4) & this.whitePieces;\n                canJump = (((temp & MASK_L3) << 3) | ((temp & MASK_L5) << 5)) & sourceMask;\n            }\n            if (!canJump && isKing) {\n                temp = (((destinationMask & MASK_L3) << 3) | ((destinationMask & MASK_L5) << 5)) & this.whitePieces;\n                canJump = (temp << 4) & sourceMask;\n            }\n            if (canJump) {\n                let whitePieces = this.whitePieces ^ temp;\n                let blackPieces = (this.blackPieces | destinationMask) ^ sourceMask;\n                let kings = this.kings | (destinationMask & 0xF0000000);\n                let canJumpAgain = (kings == this.kings) &&\n                    (this.getJumpersBlack(whitePieces, blackPieces, kings) & destinationMask);\n                let player = canJumpAgain ? Player.Black : Player.White;\n                return {\n                    success: true,\n                    board: new Bitboard(whitePieces, blackPieces, kings, player)\n                };\n            }\n        }\n        return { success: false };\n    }\n    tryMove(source, destination) {\n        const failureResult = { success: false };\n        const sourceMask = S[source];\n        const destinationMask = S[destination];\n        const isKing = sourceMask & this.kings;\n        if (this.winner != Player.None) {\n            return failureResult;\n        }\n        if (this.player != this.getPlayerAtSquare(source)) {\n            return failureResult;\n        }\n        if (this.getPlayerAtSquare(destination) != Player.None) {\n            return failureResult;\n        }\n        let jumpers = this.player == Player.White ?\n            this.getJumpersWhite() :\n            this.getJumpersBlack();\n        if (jumpers) {\n            return (jumpers & sourceMask) ?\n                this.tryJump(source, destination) :\n                failureResult;\n        }\n        let steppers = this.player == Player.White ?\n            this.getSteppersWhite() :\n            this.getSteppersBlack();\n        if (steppers) {\n            return (steppers & sourceMask) ?\n                this.tryStep(source, destination) :\n                failureResult;\n        }\n        return failureResult;\n    }\n}\nexports.Bitboard = Bitboard;\n","\"use strict\";\nconst checkers_bitboard_1 = require('./checkers-bitboard');\nconst ROW_LENGTH = 8;\nconst COLUMN_LENGTH = 8;\nconst BoardSquareArray = (function () {\n    let squares = [];\n    for (let i = 0; i < ROW_LENGTH; i++) {\n        let mod2 = i % 2;\n        for (let j = 7 - mod2; j > 0 - mod2; j -= 2) {\n            squares.push({ row: i, column: j });\n        }\n    }\n    return squares.reverse();\n})();\nfunction toPosition(square, squareSize) {\n    let boardSquare = BoardSquareArray[square];\n    let x = boardSquare.column * squareSize;\n    let y = boardSquare.row * squareSize;\n    return { x: x, y: y };\n}\nfunction toSquare(position, squareSize) {\n    var row = Math.floor(position.y / squareSize);\n    var column = Math.floor(position.x / squareSize);\n    return BoardSquareArray.findIndex(bs => bs.column == column && bs.row == row);\n}\nfunction add(p1, p2) {\n    return {\n        x: p1.x + p2.x,\n        y: p1.y + p2.y\n    };\n}\nfunction subtract(p1, p2) {\n    return {\n        x: p1.x - p2.x,\n        y: p1.y - p2.y\n    };\n}\nclass CheckersBoardController {\n    constructor(checkers, $element, $window, $timeout, $log) {\n        this.checkers = checkers;\n        this.$element = $element;\n        this.$window = $window;\n        this.$timeout = $timeout;\n        this.$log = $log;\n        let canvasElement = $element[0].querySelector('canvas');\n        this.canvas = angular.element(canvasElement);\n        this.ctx = canvasElement.getContext('2d');\n        this.canvas.on(\"mousedown\", this.handleMouseDown.bind(this));\n    }\n    $onInit() {\n        this.squareSize = this.width / ROW_LENGTH;\n    }\n    $postLink() {\n        this.render();\n    }\n    render() {\n        this.$timeout(() => {\n            this.drawBoard();\n            this.drawPieces(this.checkers.getCurrentBoard());\n        });\n    }\n    handleMouseDown(ev) {\n        let p = this.getMousePoint(ev);\n        let sourceSquare = toSquare(p, this.squareSize);\n        let player = this.checkers.getCurrentBoard().getPlayerAtSquare(sourceSquare);\n        if (player == this.checkers.getCurrentBoard().player) {\n            let squarePosition = toPosition(sourceSquare, this.squareSize);\n            this.dragTarget = sourceSquare;\n            this.dragPosition = p;\n            this.dragTranslation = subtract(p, squarePosition);\n            this.canvas.on('mousemove', this.handleMouseMove.bind(this));\n            this.canvas.on('mouseup', this.handleMouseUp.bind(this));\n            this.render();\n        }\n    }\n    handleMouseMove(ev) {\n        let p = this.getMousePoint(ev);\n        this.dragPosition = p;\n        this.render();\n    }\n    handleMouseUp(ev) {\n        let p = this.getMousePoint(ev);\n        let destinationSquare = toSquare(p, this.squareSize);\n        if (destinationSquare >= 0) {\n            this.checkers.tryMove(this.dragTarget, destinationSquare);\n        }\n        this.dragTarget = -1;\n        this.dragPosition = null;\n        this.canvas.off('mousemove');\n        this.canvas.off('mouseup');\n        this.render();\n    }\n    getMousePoint(ev) {\n        let rect = this.canvas[0].getBoundingClientRect();\n        return {\n            x: ev.clientX - rect.left,\n            y: ev.clientY - rect.top\n        };\n    }\n    drawPiece(point, fillColor, strokeColor, translation) {\n        const halfSquare = (this.squareSize * 0.5);\n        const x = point.x + translation.x;\n        const y = point.y + translation.y;\n        this.ctx.beginPath();\n        this.ctx.fillStyle = fillColor;\n        this.ctx.lineWidth = 5;\n        this.ctx.strokeStyle = strokeColor;\n        this.ctx.arc(x, y, halfSquare - 10, 0, 2 * Math.PI, false);\n        this.ctx.closePath();\n        this.ctx.stroke();\n        this.ctx.fill();\n    }\n    drawPieces(bitboard) {\n        let drawDragTarget;\n        let translation = { x: this.squareSize * 0.5, y: this.squareSize * 0.5 };\n        for (let i = 0; i < checkers_bitboard_1.SQUARE_COUNT; i++) {\n            let fillColor;\n            let strokeColor;\n            switch (bitboard.getPlayerAtSquare(i)) {\n                case checkers_bitboard_1.Player.White:\n                    fillColor = 'white';\n                    strokeColor = 'black';\n                    break;\n                case checkers_bitboard_1.Player.Black:\n                    fillColor = 'black';\n                    strokeColor = 'white';\n                    break;\n                default:\n                    continue;\n            }\n            if (i == this.dragTarget) {\n                let dragTranslation = subtract(translation, this.dragTranslation);\n                drawDragTarget = this.drawPiece.bind(this, this.dragPosition, fillColor, strokeColor, dragTranslation);\n            }\n            else {\n                let position = toPosition(i, this.squareSize);\n                this.drawPiece(position, fillColor, strokeColor, translation);\n            }\n        }\n        if (drawDragTarget) {\n            drawDragTarget();\n        }\n    }\n    drawSquare(row, column) {\n        let color = row % 2 == column % 2 ? 'white' : 'black';\n        let x = row * this.squareSize;\n        let y = column * this.squareSize;\n        this.ctx.fillStyle = color;\n        this.ctx.fillRect(x, y, this.squareSize, this.squareSize);\n    }\n    drawBoard() {\n        for (let i = 0; i < ROW_LENGTH; i++) {\n            for (let j = 0; j < COLUMN_LENGTH; j++) {\n                this.drawSquare(i, j);\n            }\n        }\n    }\n}\nexports.CheckersBoard = {\n    template: `<canvas width=\"{{$ctrl.width}}\" height=\"{{$ctrl.height}}\">\n        <span id=\"no_html5\">Your Browser Does Not Support HTML5's Canvas Feature.</span>\n    </canvas>`,\n    bindings: {\n        width: '<',\n        height: '<'\n    },\n    controller: CheckersBoardController\n};\n","\"use strict\";\nconst checkers_service_1 = require('./checkers-service');\nclass GameMenuController {\n    constructor(checkers, $interval) {\n        this.checkers = checkers;\n        this.$interval = $interval;\n        this.$interval(() => {\n            let endTime = new Date();\n            this.playTime = (endTime.getTime() - this.checkers.getStartTime()) / 1000;\n        }, 1000);\n    }\n    getCurrentPlayer() {\n        switch (this.checkers.getCurrentPlayer()) {\n            case checkers_service_1.Player.White:\n                return 'White';\n            case checkers_service_1.Player.Black:\n                return 'Black';\n            default:\n                throw new Error('Unexpected player');\n        }\n    }\n    undoMove() {\n        return false;\n    }\n    getPlayTime() {\n        return this.playTime;\n    }\n}\nfunction TimeFormatFilter() {\n    return function (value) {\n        value = value || 0;\n        let seconds = Math.round(value % 60);\n        value = Math.floor(value / 60);\n        let minutes = Math.round(value % 60);\n        value = Math.floor(value / 60);\n        let hours = Math.round(value % 24);\n        value = Math.floor(value / 24);\n        let days = value;\n        if (days) {\n            return `${days} days, ${hours} hrs, ${minutes} mins, ${seconds} secs`;\n        }\n        else if (hours) {\n            return `${hours} hrs, ${minutes} mins, ${seconds} secs`;\n        }\n        else if (minutes) {\n            return minutes == 1 ? `${minutes} mins, ${seconds} secs` : `${minutes} mins, ${seconds} secs`;\n        }\n        else {\n            return `${seconds} secs`;\n        }\n    };\n}\nexports.TimeFormatFilter = TimeFormatFilter;\n;\nexports.CheckersGameMenu = {\n    templateUrl: './templates/game-menu.html',\n    controller: GameMenuController\n};\n","\"use strict\";\nconst checkers_service_1 = require('./checkers-service');\nclass GameStatsController {\n    constructor(checkers, $interval) {\n        this.checkers = checkers;\n        this.$interval = $interval;\n        this.$interval(() => {\n            let endTime = new Date();\n            this.playTime = (endTime.getTime() - this.checkers.getStartTime()) / 1000;\n        }, 1000);\n    }\n    getCurrentPlayer() {\n        switch (this.checkers.getCurrentPlayer()) {\n            case checkers_service_1.Player.White:\n                return 'White';\n            case checkers_service_1.Player.Black:\n                return 'Black';\n            default:\n                throw new Error('Unexpected player');\n        }\n    }\n    undoMove() {\n        return false;\n    }\n    getPlayTime() {\n        return this.playTime;\n    }\n}\nfunction TimeFormatFilter() {\n    return function (value) {\n        value = value || 0;\n        let seconds = Math.round(value % 60);\n        value = Math.floor(value / 60);\n        let minutes = Math.round(value % 60);\n        value = Math.floor(value / 60);\n        let hours = Math.round(value % 24);\n        value = Math.floor(value / 24);\n        let days = value;\n        if (days) {\n            return `${days} days, ${hours} hrs, ${minutes} mins, ${seconds} secs`;\n        }\n        else if (hours) {\n            return `${hours} hrs, ${minutes} mins, ${seconds} secs`;\n        }\n        else if (minutes) {\n            return minutes == 1 ? `${minutes} mins, ${seconds} secs` : `${minutes} mins, ${seconds} secs`;\n        }\n        else {\n            return `${seconds} secs`;\n        }\n    };\n}\nexports.TimeFormatFilter = TimeFormatFilter;\n;\nexports.CheckersGameStats = {\n    templateUrl: './templates/game-stats.ng',\n    controller: GameStatsController\n};\n","\"use strict\";\nconst checkers_service_1 = require('./checkers-service');\nconst checkers_board_1 = require('./checkers-board');\nconst checkers_game_stats_1 = require('./checkers-game-stats');\nexports.CheckersModule = angular.module('Checkers', []);\nexports.CheckersModule.provider('checkers', checkers_service_1.CheckersProvider);\nexports.CheckersModule.component('checkersBoard', checkers_board_1.CheckersBoard);\nexports.CheckersModule.component('checkersGameStats', checkers_game_stats_1.CheckersGameStats);\nexports.CheckersModule.filter('timeFilter', checkers_game_stats_1.TimeFormatFilter);\n","\"use strict\";\nconst checkers_bitboard_1 = require('./checkers-bitboard');\nvar checkers_bitboard_2 = require('./checkers-bitboard');\nexports.Player = checkers_bitboard_2.Player;\nclass Checkers {\n    constructor() {\n        this.boards = [];\n        this.boards.push(new checkers_bitboard_1.Bitboard());\n        this.startTime = (new Date()).getTime();\n    }\n    getCurrentPlayer() {\n        return this.getCurrentBoard().player;\n    }\n    getCurrentBoard() {\n        return this.boards[this.boards.length - 1];\n    }\n    getStartTime() {\n        return this.startTime;\n    }\n    tryMove(source, destination) {\n        let currentBoard = this.getCurrentBoard();\n        let { success, board } = currentBoard.tryMove(source, destination);\n        if (success) {\n            this.boards.push(board);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n}\nexports.Checkers = Checkers;\nclass CheckersProvider {\n    $get($injector) {\n        return $injector.instantiate(Checkers);\n    }\n}\nexports.CheckersProvider = CheckersProvider;\n"]}