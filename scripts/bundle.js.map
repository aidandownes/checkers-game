{"version":3,"sources":["node_modules/browser-pack/_prelude.js","scripts/js/app.js","scripts/js/assert.js","scripts/js/checkers-bitboard.js","scripts/js/checkers-board.js","scripts/js/checkers-game-menu.js","scripts/js/checkers-game-stats.js","scripts/js/checkers-mcts-stats.js","scripts/js/checkers-module.js","scripts/js/checkers-service.js","scripts/js/collections.js","scripts/js/game-model.js","scripts/js/mcts.js","scripts/js/uct.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","\"use strict\";\nconst checkers_module_1 = require('./checkers-module');\nexports.AppModule = angular.module('app', [checkers_module_1.CheckersModule.name, 'ngMaterial']);\nfunction configureThemes($mdThemingProvider) {\n    $mdThemingProvider.theme('default')\n        .primaryPalette('blue')\n        .accentPalette('deep-orange')\n        .backgroundPalette('grey', {\n        'default': '50'\n    });\n    $mdThemingProvider.theme('card-default')\n        .backgroundPalette('grey');\n    $mdThemingProvider.theme('card-blue-dark')\n        .backgroundPalette('blue')\n        .dark();\n    $mdThemingProvider.theme('card-red')\n        .backgroundPalette('red')\n        .dark();\n}\nexports.AppModule.config(configureThemes);\nclass AppController {\n    constructor(checkers, $mdSidenav, $scope) {\n        this.checkers = checkers;\n        this.$mdSidenav = $mdSidenav;\n        this.$scope = $scope;\n        this.computeOptions = checkers.getComputeOptions();\n        $scope.$watchCollection(() => this.computeOptions, (options) => {\n            checkers.setComputeOptions(options);\n        });\n        $scope.$watch(() => this.isSidenavOpen, (newValue, oldValue) => {\n            if (!newValue && oldValue) {\n                this.checkers.reset();\n            }\n        });\n    }\n    toggleMenu() {\n        this.$mdSidenav('left').toggle();\n    }\n    restart() {\n        this.checkers.reset();\n    }\n}\nexports.AppModule.controller('AppController', AppController);\n","\"use strict\";\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || 'Assert failed');\n    }\n}\nexports.assert = assert;\nfunction assertNotEmpty(list, message) {\n    if (!list || list.length == 0) {\n        throw new Error(message || 'Assert failed: List not empty');\n    }\n}\nexports.assertNotEmpty = assertNotEmpty;\nfunction assertEmpty(list, message) {\n    if (!list || list.length != 0) {\n        throw new Error(message || 'Assert failed: List empty');\n    }\n}\nexports.assertEmpty = assertEmpty;\n","\"use strict\";\nconst game_model_1 = require('./game-model');\nconst Asserts = require('./assert');\nconst S = (function () {\n    let squares = [];\n    for (let i = 0; i < 32; i++) {\n        squares.push(1 << i);\n    }\n    return squares;\n})();\nconst MASK_L3 = S[1] | S[2] | S[3] | S[9] | S[10] | S[11] | S[17] | S[18] | S[19] | S[25] | S[26] | S[27];\nconst MASK_L5 = S[4] | S[5] | S[6] | S[12] | S[13] | S[14] | S[20] | S[21] | S[22];\nconst MASK_R3 = S[28] | S[29] | S[30] | S[20] | S[21] | S[22] | S[12] | S[13] | S[14] | S[4] | S[5] | S[6];\nconst MASK_R5 = S[25] | S[26] | S[27] | S[17] | S[18] | S[19] | S[9] | S[10] | S[11];\nexports.SQUARE_COUNT = 32;\nclass Bitboard {\n    constructor(whitePieces = 0xFFF00000, blackPieces = 0x00000FFF, kings = 0, player = game_model_1.Player.One) {\n        this.whitePieces = whitePieces;\n        this.blackPieces = blackPieces;\n        this.kings = kings;\n        this.player = player;\n        if (this.player == game_model_1.Player.One) {\n            let canPlay = this.getJumpersWhite() || this.getHoppersWhite();\n            this.winner = canPlay ? game_model_1.Player.None : game_model_1.Player.Two;\n        }\n        else {\n            let canPlay = this.getJumpersBlack() || this.getHoppersBlack();\n            this.winner = canPlay ? game_model_1.Player.None : game_model_1.Player.One;\n        }\n        Asserts.assert((blackPieces & whitePieces) == 0);\n    }\n    doMove(move) {\n        let result = this.tryMove(move);\n        Asserts.assert(result.success, 'Move was not succesful');\n        return result.board;\n    }\n    doRandomMove() {\n        let moves = this.getMoves();\n        Asserts.assertNotEmpty(moves);\n        let randomMoveIndex = Math.floor(Math.random() * moves.length);\n        return this.doMove(moves[randomMoveIndex]);\n    }\n    hasMoves() {\n        return this.getMoves().length > 0;\n    }\n    getMoves() {\n        if (!this.moves) {\n            this.moves = [];\n            let jumpers = (this.player == game_model_1.Player.One) ?\n                this.getJumpersWhite() :\n                this.getJumpersBlack();\n            for (let i = 0; i < exports.SQUARE_COUNT; i++) {\n                if (S[i] & jumpers) {\n                    Array.prototype.push.apply(this.moves, this.getJumpMoves(i));\n                }\n            }\n            if (this.moves.length == 0) {\n                let hoppers = (this.player == game_model_1.Player.One) ?\n                    this.getHoppersWhite() :\n                    this.getHoppersBlack();\n                for (let i = 0; i < exports.SQUARE_COUNT; i++) {\n                    if (S[i] & hoppers) {\n                        Array.prototype.push.apply(this.moves, this.getHopMoves(i));\n                    }\n                }\n            }\n        }\n        return this.moves;\n    }\n    getResult(player) {\n        Asserts.assert(this.winner == game_model_1.Player.One || this.winner == game_model_1.Player.Two);\n        return this.winner == player ? game_model_1.Result.Win : game_model_1.Result.Lose;\n    }\n    getPlayerToMove() {\n        return this.player;\n    }\n    getOpponent(player) {\n        switch (player) {\n            case game_model_1.Player.One:\n                return game_model_1.Player.Two;\n            case game_model_1.Player.Two:\n                return game_model_1.Player.One;\n            default:\n                return game_model_1.Player.None;\n        }\n    }\n    getPlayerAtSquare(square) {\n        const mask = S[square];\n        if (this.whitePieces & mask) {\n            return game_model_1.Player.One;\n        }\n        else if (this.blackPieces & mask) {\n            return game_model_1.Player.Two;\n        }\n        else {\n            return game_model_1.Player.None;\n        }\n    }\n    isKing(square) {\n        const mask = S[square];\n        return !!(this.kings & mask);\n    }\n    getHopMoves(source) {\n        let moves = [];\n        const mask = S[source];\n        const notOccupied = ~(this.whitePieces | this.blackPieces);\n        const isKing = mask & this.kings;\n        const player = this.player;\n        var hops = 0;\n        if (isKing || (player == game_model_1.Player.One)) {\n            hops |= (mask >>> 4) & notOccupied;\n            hops |= ((mask & MASK_R3) >>> 3) & notOccupied;\n            hops |= ((mask & MASK_R5) >>> 5) & notOccupied;\n        }\n        if (isKing || (player == game_model_1.Player.Two)) {\n            hops |= (mask << 4) & notOccupied;\n            hops |= ((mask & MASK_L3) << 3) & notOccupied;\n            hops |= ((mask & MASK_L5) << 5) & notOccupied;\n        }\n        for (let destination = 0; destination < 32; destination++) {\n            if (S[destination] & hops) {\n                moves.push({ source: source, destination: destination, player: player });\n            }\n        }\n        return moves;\n    }\n    rightJump(opponentPieces, notOccupied, mask) {\n        var jumps = 0;\n        let temp = (mask >>> 4) & opponentPieces;\n        jumps |= (((temp & MASK_R3) >>> 3) | ((temp & MASK_R5) >>> 5)) & notOccupied;\n        temp = (((mask & MASK_R3) >>> 3) | ((mask & MASK_R5) >>> 5)) & opponentPieces;\n        jumps |= (temp >>> 4) & notOccupied;\n        return jumps;\n    }\n    leftJump(opponentPieces, notOccupied, mask) {\n        var jumps = 0;\n        let temp = (mask << 4) & opponentPieces;\n        jumps |= (((temp & MASK_L3) << 3) | ((temp & MASK_L5) << 5)) & notOccupied;\n        temp = (((mask & MASK_L3) << 3) | ((mask & MASK_L5) << 5)) & opponentPieces;\n        jumps |= (temp << 4) & notOccupied;\n        return jumps;\n    }\n    getJumpMoves(source) {\n        let moves = [];\n        const mask = S[source];\n        const notOccupied = ~(this.whitePieces | this.blackPieces);\n        const isKing = mask & this.kings;\n        const player = this.player;\n        var jumps = 0;\n        if (player == game_model_1.Player.One) {\n            jumps |= this.rightJump(this.blackPieces, notOccupied, mask);\n            if (isKing) {\n                jumps |= this.leftJump(this.blackPieces, notOccupied, mask);\n            }\n        }\n        else if (player == game_model_1.Player.Two) {\n            jumps |= this.leftJump(this.whitePieces, notOccupied, mask);\n            if (isKing) {\n                jumps |= this.rightJump(this.whitePieces, notOccupied, mask);\n            }\n        }\n        for (let destination = 0; destination < 32; destination++) {\n            if (S[destination] & jumps) {\n                moves.push({ source: source, destination: destination, player: player });\n            }\n        }\n        return moves;\n    }\n    getHoppersWhite() {\n        if (this.player != game_model_1.Player.One) {\n            return 0;\n        }\n        const notOccupied = ~(this.whitePieces | this.blackPieces);\n        const kingPieces = this.whitePieces & this.kings;\n        var movers = (notOccupied << 4) & this.whitePieces;\n        movers |= ((notOccupied & MASK_L3) << 3) & this.whitePieces;\n        movers |= ((notOccupied & MASK_L5) << 5) & this.whitePieces;\n        if (kingPieces) {\n            movers |= (notOccupied >>> 4) & kingPieces;\n            movers |= ((notOccupied & MASK_R3) >>> 3) & kingPieces;\n            movers |= ((notOccupied & MASK_R5) >>> 5) & kingPieces;\n        }\n        return movers;\n    }\n    getHoppersBlack() {\n        if (this.player != game_model_1.Player.Two) {\n            return 0;\n        }\n        const notOccupied = ~(this.whitePieces | this.blackPieces);\n        const kingPieces = this.blackPieces & this.kings;\n        var movers = (notOccupied >>> 4) & this.blackPieces;\n        movers |= ((notOccupied & MASK_R3) >>> 3) & this.blackPieces;\n        movers |= ((notOccupied & MASK_R5) >>> 5) & this.blackPieces;\n        if (kingPieces) {\n            movers |= (notOccupied << 4) & kingPieces;\n            movers |= ((notOccupied & MASK_L3) << 3) & kingPieces;\n            movers |= ((notOccupied & MASK_L5) << 5) & kingPieces;\n        }\n        return movers;\n    }\n    getJumpersWhite(whitePieces, blackPieces, kings) {\n        whitePieces = whitePieces || this.whitePieces;\n        blackPieces = blackPieces || this.blackPieces;\n        kings = kings || this.kings;\n        const notOccupied = ~(whitePieces | blackPieces);\n        const kingPieces = whitePieces & kings;\n        var movers = 0;\n        let temp = (notOccupied << 4) & blackPieces;\n        movers |= (((temp & MASK_L3) << 3) | ((temp & MASK_L5) << 5)) & whitePieces;\n        temp = (((notOccupied & MASK_L3) << 3) | ((notOccupied & MASK_L5) << 5)) & blackPieces;\n        movers |= (temp << 4) & whitePieces;\n        if (kingPieces) {\n            temp = (notOccupied >>> 4) & blackPieces;\n            movers |= (((temp & MASK_R3) >>> 3) | ((temp & MASK_R5) >>> 5)) & kingPieces;\n            temp = (((notOccupied & MASK_R3) >>> 3) | ((notOccupied & MASK_R5) >>> 5)) & blackPieces;\n            movers |= (temp >>> 4) & kingPieces;\n        }\n        return movers;\n    }\n    getJumpersBlack(whitePieces, blackPieces, kings) {\n        whitePieces = whitePieces || this.whitePieces;\n        blackPieces = blackPieces || this.blackPieces;\n        kings = kings || this.kings;\n        const notOccupied = ~(whitePieces | blackPieces);\n        const kingPieces = blackPieces & kings;\n        var movers = 0;\n        let temp = (notOccupied >>> 4) & whitePieces;\n        movers |= (((temp & MASK_R3) >>> 3) | ((temp & MASK_R5) >>> 5)) & blackPieces;\n        temp = (((notOccupied & MASK_R3) >>> 3) | ((notOccupied & MASK_R5) >>> 5)) & whitePieces;\n        movers |= (temp >>> 4) & blackPieces;\n        if (kingPieces) {\n            temp = (notOccupied << 4) & whitePieces;\n            movers |= (((temp & MASK_L3) << 3) | ((temp & MASK_L5) << 5)) & kingPieces;\n            temp = (((notOccupied & MASK_L3) << 3) | ((notOccupied & MASK_L5) << 5)) & whitePieces;\n            movers |= (temp << 4) & kingPieces;\n        }\n        return movers;\n    }\n    tryStep(source, destination) {\n        let sourceMask = S[source];\n        let destinationMask = S[destination];\n        let isKing = sourceMask & this.kings;\n        if (this.player == game_model_1.Player.One) {\n            var canMove = (destinationMask << 4) & sourceMask;\n            canMove |= ((destinationMask & MASK_L3) << 3) & sourceMask;\n            canMove |= ((destinationMask & MASK_L5) << 5) & sourceMask;\n            if (isKing) {\n                canMove |= (destinationMask >>> 4) & sourceMask;\n                canMove |= ((destinationMask & MASK_R3) >>> 3) & sourceMask;\n                canMove |= ((destinationMask & MASK_R5) >>> 5) & sourceMask;\n            }\n            if (canMove) {\n                let whitePieces = (this.whitePieces | destinationMask) ^ sourceMask;\n                let blackPieces = this.blackPieces;\n                let kings = isKing ?\n                    (this.kings | destinationMask) ^ sourceMask :\n                    this.kings | (destinationMask & 0xF);\n                let player = game_model_1.Player.Two;\n                return {\n                    success: true,\n                    board: new Bitboard(whitePieces, blackPieces, kings, player)\n                };\n            }\n        }\n        else if (this.player = game_model_1.Player.Two) {\n            var canMove = (destinationMask >>> 4) & sourceMask;\n            canMove |= ((destinationMask & MASK_R3) >>> 3) & sourceMask;\n            canMove |= ((destinationMask & MASK_R5) >>> 5) & sourceMask;\n            if (isKing) {\n                canMove |= (destinationMask << 4) & sourceMask;\n                canMove |= ((destinationMask & MASK_L3) << 3) & sourceMask;\n                canMove |= ((destinationMask & MASK_L5) << 5) & sourceMask;\n            }\n            if (canMove) {\n                let whitePieces = this.whitePieces;\n                let blackPieces = (this.blackPieces | destinationMask) ^ sourceMask;\n                let kings = isKing ?\n                    (this.kings | destinationMask) ^ sourceMask :\n                    this.kings | (destinationMask & 0xF0000000);\n                let player = game_model_1.Player.One;\n                return {\n                    success: true,\n                    board: new Bitboard(whitePieces, blackPieces, kings, player)\n                };\n            }\n        }\n        return { success: false };\n    }\n    tryJump(source, destination) {\n        let sourceMask = S[source];\n        let destinationMask = S[destination];\n        let isKing = sourceMask & this.kings;\n        if (this.player == game_model_1.Player.One) {\n            let canJump;\n            let temp = (destinationMask << 4) & this.blackPieces;\n            canJump = (((temp & MASK_L3) << 3) | ((temp & MASK_L5) << 5)) & sourceMask;\n            if (!canJump) {\n                temp = (((destinationMask & MASK_L3) << 3) | ((destinationMask & MASK_L5) << 5)) & this.blackPieces;\n                canJump = (temp << 4) & sourceMask;\n            }\n            if (!canJump && isKing) {\n                temp = (destinationMask >>> 4) & this.blackPieces;\n                canJump = (((temp & MASK_R3) >>> 3) | ((temp & MASK_R5) >>> 5)) & sourceMask;\n            }\n            if (!canJump && isKing) {\n                temp = (((destinationMask & MASK_R3) >>> 3) | ((destinationMask & MASK_R5) >>> 5)) & this.blackPieces;\n                canJump = (temp >> 4) & sourceMask;\n            }\n            if (canJump) {\n                let whitePieces = (this.whitePieces | destinationMask) ^ sourceMask;\n                let blackPieces = this.blackPieces ^ temp;\n                let kings = (this.kings & sourceMask) ?\n                    (this.kings | destinationMask) ^ sourceMask :\n                    this.kings | (destinationMask & 0xF);\n                if (kings & temp) {\n                    kings = kings ^ temp;\n                }\n                let canJumpAgain = !(destinationMask & 0xF) &&\n                    (this.getJumpersWhite(whitePieces, blackPieces, kings) & destinationMask);\n                let player = canJumpAgain ? game_model_1.Player.One : game_model_1.Player.Two;\n                return {\n                    success: true,\n                    board: new Bitboard(whitePieces, blackPieces, kings, player)\n                };\n            }\n        }\n        else if (this.player == game_model_1.Player.Two) {\n            let canJump;\n            let temp = (destinationMask >>> 4) & this.whitePieces;\n            canJump = (((temp & MASK_R3) >>> 3) | ((temp & MASK_R5) >>> 5)) & sourceMask;\n            if (!canJump) {\n                temp = (((destinationMask & MASK_R3) >>> 3) | ((destinationMask & MASK_R5) >>> 5)) & this.whitePieces;\n                canJump = (temp >>> 4) & sourceMask;\n            }\n            if (!canJump && isKing) {\n                temp = (destinationMask << 4) & this.whitePieces;\n                canJump = (((temp & MASK_L3) << 3) | ((temp & MASK_L5) << 5)) & sourceMask;\n            }\n            if (!canJump && isKing) {\n                temp = (((destinationMask & MASK_L3) << 3) | ((destinationMask & MASK_L5) << 5)) & this.whitePieces;\n                canJump = (temp << 4) & sourceMask;\n            }\n            if (canJump) {\n                let whitePieces = this.whitePieces ^ temp;\n                let blackPieces = (this.blackPieces | destinationMask) ^ sourceMask;\n                let kings = (this.kings & sourceMask) ?\n                    (this.kings | destinationMask) ^ sourceMask :\n                    this.kings | (destinationMask & 0xF0000000);\n                if (kings & temp) {\n                    kings = kings ^ temp;\n                }\n                let canJumpAgain = !(destinationMask & 0xF0000000) &&\n                    (this.getJumpersBlack(whitePieces, blackPieces, kings) & destinationMask);\n                let player = canJumpAgain ? game_model_1.Player.Two : game_model_1.Player.One;\n                return {\n                    success: true,\n                    board: new Bitboard(whitePieces, blackPieces, kings, player)\n                };\n            }\n        }\n        return { success: false };\n    }\n    tryMove(move) {\n        const failureResult = { success: false };\n        const sourceMask = S[move.source];\n        const destinationMask = S[move.destination];\n        const isKing = sourceMask & this.kings;\n        if (this.winner != game_model_1.Player.None) {\n            failureResult.message = 'Game is over';\n            return failureResult;\n        }\n        if (this.player != this.getPlayerAtSquare(move.source)) {\n            failureResult.message = 'Wrong player move';\n            return failureResult;\n        }\n        if (this.getPlayerAtSquare(move.destination) != game_model_1.Player.None) {\n            failureResult.message = 'Destination is not empty';\n            return failureResult;\n        }\n        let jumpers = this.player == game_model_1.Player.One ?\n            this.getJumpersWhite() :\n            this.getJumpersBlack();\n        if (jumpers) {\n            let shouldJump = jumpers & sourceMask;\n            if (shouldJump) {\n                return this.tryJump(move.source, move.destination);\n            }\n            else {\n                failureResult.message = 'Player should jump';\n                return failureResult;\n            }\n        }\n        return this.tryStep(move.source, move.destination);\n    }\n    toString() {\n        let buffer = [];\n        let prependSpace = false;\n        let getPieceString = (index) => {\n            let mask = S[index];\n            let pieceString = '__';\n            if (mask & this.blackPieces) {\n                pieceString = (mask & this.kings) ? 'BK' : 'BP';\n            }\n            else if (mask & this.whitePieces) {\n                pieceString = (mask & this.kings) ? 'WK' : 'WP';\n            }\n            return pieceString;\n        };\n        for (let i = 0; i < exports.SQUARE_COUNT; i += 4) {\n            let lineBuffer = [];\n            for (let j = i; j < i + 4; j++) {\n                if (prependSpace) {\n                    lineBuffer.push(' ');\n                }\n                lineBuffer.push(getPieceString(j));\n                if (!prependSpace) {\n                    lineBuffer.push(' ');\n                }\n            }\n            lineBuffer.push('\\n');\n            prependSpace = !prependSpace;\n            buffer.splice(0, 0, lineBuffer.join(' '));\n        }\n        return buffer.join(' ');\n    }\n}\nexports.Bitboard = Bitboard;\n","\"use strict\";\nconst checkers_bitboard_1 = require('./checkers-bitboard');\nconst game_model_1 = require('./game-model');\nconst ROW_LENGTH = 8;\nconst COLUMN_LENGTH = 8;\nclass Point {\n    constructor(x, y) {\n        this.x_ = x;\n        this.y_ = y;\n    }\n    get x() {\n        return this.x_;\n    }\n    get y() {\n        return this.y_;\n    }\n    add(other) {\n        return new Point(this.x_ + other.x_, this.y_ + other.y_);\n    }\n    subtract(other) {\n        return new Point(this.x_ - other.x_, this.y_ - other.y_);\n    }\n}\nconst BoardSquareArray = (function () {\n    let squares = [];\n    for (let i = 0; i < ROW_LENGTH; i++) {\n        let mod2 = i % 2;\n        for (let j = 7 - mod2; j > 0 - mod2; j -= 2) {\n            squares.push({ row: i, column: j });\n        }\n    }\n    return squares.reverse();\n})();\nfunction toPosition(square, squareSize) {\n    let boardSquare = BoardSquareArray[square];\n    let x = boardSquare.column * squareSize;\n    let y = boardSquare.row * squareSize;\n    return new Point(x, y);\n}\nfunction toSquare(position, squareSize) {\n    var row = Math.floor(position.y / squareSize);\n    var column = Math.floor(position.x / squareSize);\n    return BoardSquareArray.findIndex(bs => bs.column == column && bs.row == row);\n}\nclass CheckersBoardController {\n    constructor(checkers, $element, $window, $timeout, $log, $scope, $q) {\n        this.checkers = checkers;\n        this.$element = $element;\n        this.$window = $window;\n        this.$timeout = $timeout;\n        this.$log = $log;\n        this.$scope = $scope;\n        this.$q = $q;\n        this.canvasElement = $element[0].querySelector('canvas');\n        this.canvas = angular.element(this.canvasElement);\n        this.ctx = this.canvasElement.getContext('2d');\n        this.width = this.$element.width();\n        this.height = this.$element.height();\n        this.squareSize = this.width / ROW_LENGTH;\n        this.canvas.on('mousedown', this.handleMouseDown.bind(this));\n        $scope.$watch(() => this.$element.width(), this.resize.bind(this));\n        $scope.$watch(() => this.checkers.getCurrentBoard(), () => this.render());\n    }\n    $postLink() {\n        this.spritesPromise = this.loadImage(this.spritesImageUrl);\n        this.render();\n    }\n    loadImage(src) {\n        let defer = this.$q.defer();\n        let img = new Image();\n        img.src = src;\n        img.onload = (ev) => {\n            defer.resolve(img);\n        };\n        return defer.promise;\n    }\n    render() {\n        this.spritesPromise.then(() => {\n            this.$timeout(() => {\n                this.drawBoard();\n                this.drawPieces(this.checkers.getCurrentBoard());\n            });\n        });\n    }\n    resize() {\n        this.width = this.$element.width();\n        this.height = this.$element.height();\n        this.squareSize = this.width / ROW_LENGTH;\n        this.canvasElement.width = this.width;\n        this.canvasElement.height = this.width;\n        this.render();\n    }\n    handleMouseDown(ev) {\n        let p = this.getMousePoint(ev);\n        let sourceSquare = toSquare(p, this.squareSize);\n        let player = this.checkers.getCurrentBoard().getPlayerAtSquare(sourceSquare);\n        if (player == this.checkers.getCurrentBoard().player) {\n            let squarePosition = toPosition(sourceSquare, this.squareSize);\n            this.dragTarget = sourceSquare;\n            this.dragPosition = p;\n            this.dragTranslation = p.subtract(squarePosition);\n            this.canvas.on('mousemove', this.handleMouseMove.bind(this));\n            this.canvas.on('mouseup', this.handleMouseUp.bind(this));\n            this.render();\n        }\n    }\n    handleMouseMove(ev) {\n        let p = this.getMousePoint(ev);\n        this.dragPosition = p;\n        this.render();\n    }\n    handleMouseUp(ev) {\n        let p = this.getMousePoint(ev);\n        let destinationSquare = toSquare(p, this.squareSize);\n        if (destinationSquare >= 0) {\n            this.checkers.tryMove(this.dragTarget, destinationSquare);\n        }\n        this.dragTarget = -1;\n        this.dragPosition = null;\n        this.canvas.off('mousemove');\n        this.canvas.off('mouseup');\n        this.render();\n    }\n    getMousePoint(ev) {\n        let rect = this.canvas[0].getBoundingClientRect();\n        return new Point(ev.clientX - rect.left, ev.clientY - rect.top);\n    }\n    drawPiece(point, player, isKing, translation) {\n        this.spritesPromise.then(img => {\n            let sourceX = isKing ? (2 * this.spriteSize) : 0;\n            if (player == game_model_1.Player.One) {\n                sourceX += this.spriteSize;\n            }\n            let spriteAdjust = new Point(2, 2);\n            let drawPoint = point.add(spriteAdjust);\n            if (translation) {\n                drawPoint = drawPoint.subtract(translation);\n            }\n            this.ctx.drawImage(img, sourceX, 0, this.spriteSize, this.spriteSize, drawPoint.x, drawPoint.y, this.squareSize, this.squareSize);\n        });\n    }\n    drawPieces(bitboard) {\n        let drawDragTarget;\n        for (let i = 0; i < checkers_bitboard_1.SQUARE_COUNT; i++) {\n            let player = bitboard.getPlayerAtSquare(i);\n            if (player == game_model_1.Player.None) {\n                continue;\n            }\n            let isKing = bitboard.isKing(i);\n            if (i == this.dragTarget) {\n                drawDragTarget = this.drawPiece.bind(this, this.dragPosition, player, isKing, this.dragTranslation);\n            }\n            else {\n                let position = toPosition(i, this.squareSize);\n                this.drawPiece(position, player, isKing);\n            }\n        }\n        if (drawDragTarget) {\n            drawDragTarget();\n        }\n    }\n    drawSquare(row, column) {\n        let color = (row % 2 == column % 2) ? 'white' : 'black';\n        let x = row * this.squareSize;\n        let y = column * this.squareSize;\n        this.ctx.fillStyle = color;\n        this.ctx.fillRect(x, y, this.squareSize, this.squareSize);\n    }\n    drawBoard() {\n        for (let i = 0; i < ROW_LENGTH; i++) {\n            for (let j = 0; j < COLUMN_LENGTH; j++) {\n                this.drawSquare(i, j);\n            }\n        }\n    }\n}\nexports.CheckersBoard = {\n    template: `<canvas>\n        <span id=\"no_html5\">Your Browser Does Not Support HTML5's Canvas Feature.</span>\n    </canvas>`,\n    bindings: {\n        spritesImageUrl: '@',\n        spriteSize: '<'\n    },\n    controller: CheckersBoardController\n};\n","\"use strict\";\nconst checkers_service_1 = require('./checkers-service');\nclass GameMenuController {\n    constructor(checkers, $interval) {\n        this.checkers = checkers;\n        this.$interval = $interval;\n        this.$interval(() => {\n            let endTime = new Date();\n            this.playTime = (endTime.getTime() - this.checkers.getStartTime()) / 1000;\n        }, 1000);\n    }\n    getCurrentPlayer() {\n        switch (this.checkers.getCurrentPlayer()) {\n            case checkers_service_1.Player.White:\n                return 'White';\n            case checkers_service_1.Player.Black:\n                return 'Black';\n            default:\n                throw new Error('Unexpected player');\n        }\n    }\n    undoMove() {\n        return false;\n    }\n    getPlayTime() {\n        return this.playTime;\n    }\n}\nfunction TimeFormatFilter() {\n    return function (value) {\n        value = value || 0;\n        let seconds = Math.round(value % 60);\n        value = Math.floor(value / 60);\n        let minutes = Math.round(value % 60);\n        value = Math.floor(value / 60);\n        let hours = Math.round(value % 24);\n        value = Math.floor(value / 24);\n        let days = value;\n        if (days) {\n            return `${days} days, ${hours} hrs, ${minutes} mins, ${seconds} secs`;\n        }\n        else if (hours) {\n            return `${hours} hrs, ${minutes} mins, ${seconds} secs`;\n        }\n        else if (minutes) {\n            return minutes == 1 ? `${minutes} mins, ${seconds} secs` : `${minutes} mins, ${seconds} secs`;\n        }\n        else {\n            return `${seconds} secs`;\n        }\n    };\n}\nexports.TimeFormatFilter = TimeFormatFilter;\n;\nexports.CheckersGameMenu = {\n    templateUrl: './templates/game-menu.html',\n    controller: GameMenuController\n};\n","\"use strict\";\nconst game_model_1 = require('./game-model');\nclass GameStatsController {\n    constructor(checkers, $interval) {\n        this.checkers = checkers;\n        this.$interval = $interval;\n        this.$interval(() => {\n            let endTime = new Date();\n            this.playTime = (endTime.getTime() - this.checkers.getStartTime()) / 1000;\n        }, 1000);\n    }\n    getCurrentPlayer() {\n        switch (this.checkers.getCurrentPlayer()) {\n            case game_model_1.Player.One:\n                return 'White';\n            case game_model_1.Player.Two:\n                return 'Black';\n            default:\n                throw new Error('Unexpected player');\n        }\n    }\n    undoMove() {\n        return false;\n    }\n    getPlayTime() {\n        return this.playTime;\n    }\n}\nfunction TimeFormatFilter() {\n    return function (value) {\n        value = value || 0;\n        let seconds = Math.round(value % 60);\n        value = Math.floor(value / 60);\n        let minutes = Math.round(value % 60);\n        value = Math.floor(value / 60);\n        let hours = Math.round(value % 24);\n        value = Math.floor(value / 24);\n        let days = value;\n        if (days) {\n            return `${days} days, ${hours} hrs, ${minutes} mins, ${seconds} secs`;\n        }\n        else if (hours) {\n            return `${hours} hrs, ${minutes} mins, ${seconds} secs`;\n        }\n        else if (minutes) {\n            return minutes == 1 ? `${minutes} mins, ${seconds} secs` : `${minutes} mins, ${seconds} secs`;\n        }\n        else {\n            return `${seconds} secs`;\n        }\n    };\n}\nexports.TimeFormatFilter = TimeFormatFilter;\n;\nexports.CheckersGameStats = {\n    templateUrl: './templates/game-stats.ng',\n    controller: GameStatsController\n};\n","\"use strict\";\nclass MctsStatsController {\n    constructor(checkers, $scope) {\n        this.checkers = checkers;\n        this.$scope = $scope;\n        $scope.$watch(() => checkers.getSearchResult(), (searchResult) => {\n            this.searchResult = searchResult;\n        });\n    }\n    getWinPercentage() {\n        return this.searchResult ?\n            (1 - this.searchResult.winProbabilty) * 100 :\n            50;\n    }\n    getTime() {\n        return this.searchResult ?\n            this.searchResult.time : 0;\n    }\n    getIterations() {\n        return this.searchResult ?\n            this.searchResult.iterations : 0;\n    }\n}\nexports.CheckersMctsStats = {\n    templateUrl: './templates/mcts-stats.ng',\n    controller: MctsStatsController\n};\n","\"use strict\";\nconst checkers_service_1 = require('./checkers-service');\nconst checkers_board_1 = require('./checkers-board');\nconst checkers_game_stats_1 = require('./checkers-game-stats');\nconst checkers_mcts_stats_1 = require('./checkers-mcts-stats');\nconst uct_1 = require('./uct');\nexports.CheckersModule = angular.module('Checkers', [uct_1.UctSearchModule.name]);\nexports.CheckersModule.provider('checkers', checkers_service_1.CheckersProvider);\nexports.CheckersModule.component('checkersBoard', checkers_board_1.CheckersBoard);\nexports.CheckersModule.component('checkersGameStats', checkers_game_stats_1.CheckersGameStats);\nexports.CheckersModule.component('checkersMctsStats', checkers_mcts_stats_1.CheckersMctsStats);\nexports.CheckersModule.filter('timeFilter', checkers_game_stats_1.TimeFormatFilter);\n","\"use strict\";\nconst checkers_bitboard_1 = require('./checkers-bitboard');\nconst game_model_1 = require('./game-model');\nvar uct_1 = require('./uct');\nexports.UctSearchService = uct_1.UctSearchService;\nconst DEFAULT_MAX_TIME_MS = 500;\nconst DEFAULT_MAX_ITERATIONS = 10000;\nclass Checkers {\n    constructor($timeout, uctSearchService) {\n        this.$timeout = $timeout;\n        this.uctSearchService = uctSearchService;\n        this.setComputeOptions({\n            maxIterations: DEFAULT_MAX_ITERATIONS,\n            maxTime: DEFAULT_MAX_TIME_MS\n        });\n        this.reset();\n    }\n    reset() {\n        this.boards = [];\n        this.boards.push(new checkers_bitboard_1.Bitboard());\n        this.startTime = (new Date()).getTime();\n        this.searchResult = null;\n    }\n    setComputeOptions(computeOptions) {\n        this.computeOptions = computeOptions;\n    }\n    getComputeOptions() {\n        return this.computeOptions;\n    }\n    getComputerPlayer() {\n        return game_model_1.Player.Two;\n    }\n    getHumanPlayer() {\n        return game_model_1.Player.One;\n    }\n    getOpponent(player) {\n        if (player == game_model_1.Player.None)\n            return game_model_1.Player.None;\n        return player == game_model_1.Player.One ? game_model_1.Player.Two : game_model_1.Player.One;\n    }\n    getCurrentPlayer() {\n        return this.getCurrentBoard().player;\n    }\n    getCurrentBoard() {\n        return this.boards[this.boards.length - 1];\n    }\n    getStartTime() {\n        return this.startTime;\n    }\n    getSearchResult() {\n        return this.searchResult;\n    }\n    tryMove(source, destination) {\n        let currentBoard = this.getCurrentBoard();\n        let { success, board } = currentBoard.tryMove({ source: source, destination: destination, player: currentBoard.player });\n        if (success) {\n            this.boards.push(board);\n            if (board.player == this.getComputerPlayer()) {\n                this.$timeout(this.doComputerPlayerMove.bind(this), 500);\n            }\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    doComputerPlayerMove() {\n        this.searchResult = this.uctSearchService.search(this.getCurrentBoard(), this.computeOptions.maxIterations, this.computeOptions.maxTime);\n        if (this.searchResult.move) {\n            let move = this.searchResult.move;\n            this.tryMove(move.source, move.destination);\n        }\n    }\n}\nexports.Checkers = Checkers;\nclass CheckersProvider {\n    $get($injector) {\n        return $injector.instantiate(Checkers);\n    }\n}\nexports.CheckersProvider = CheckersProvider;\n","\"use strict\";\nclass Arrays {\n    static max(arr, compare) {\n        let len = arr.length;\n        let max;\n        while (len--) {\n            if (max == undefined) {\n                max = arr[len];\n            }\n            else if (compare(arr[len], max)) {\n                max = arr[len];\n            }\n        }\n        return max;\n    }\n}\nexports.Arrays = Arrays;\nclass ListNode {\n    constructor(data, next) {\n        this.data = data;\n        this.next = next;\n    }\n}\nclass List {\n    constructor(iterable) {\n        this.size = 0;\n        if (iterable) {\n            iterable.forEach((t) => this.add(t));\n        }\n    }\n    add(data) {\n        if (!this.start) {\n            this.start = new ListNode(data);\n            this.end = this.start;\n        }\n        else {\n            this.end.next = new ListNode(data);\n            this.end = this.end.next;\n        }\n        this.size++;\n    }\n    delete(data) {\n        let current = this.start;\n        let previous = this.start;\n        while (current) {\n            if (data === current.data) {\n                this.size--;\n                if (current === this.start) {\n                    this.start = current.next;\n                    return;\n                }\n                if (current === this.end) {\n                    this.end = previous;\n                }\n                previous.next = current.next;\n                return;\n            }\n            previous = current;\n            current = current.next;\n        }\n    }\n    item(index) {\n        let current = this.start;\n        while (current) {\n            if (index === 0) {\n                return current.data;\n            }\n            current = current.next;\n            index--;\n        }\n    }\n    forEach(f) {\n        let current = this.start;\n        while (current) {\n            f(current.data);\n            current = current.next;\n        }\n    }\n    getSize() {\n        return this.size;\n    }\n}\nexports.List = List;\n","\"use strict\";\n(function (Player) {\n    Player[Player[\"None\"] = 0] = \"None\";\n    Player[Player[\"One\"] = 1] = \"One\";\n    Player[Player[\"Two\"] = 2] = \"Two\";\n})(exports.Player || (exports.Player = {}));\nvar Player = exports.Player;\n(function (Result) {\n    Result[Result[\"Win\"] = 0] = \"Win\";\n    Result[Result[\"Lose\"] = 1] = \"Lose\";\n    Result[Result[\"Draw\"] = 2] = \"Draw\";\n})(exports.Result || (exports.Result = {}));\nvar Result = exports.Result;\n","\"use strict\";\nconst asserts = require('./assert');\nconst game_model_1 = require('./game-model');\nclass ComputeOptions {\n    constructor(maxIterations = 10000, maxTime = -1, verbose = false) {\n        this.maxIterations = maxIterations;\n        this.maxTime = maxTime;\n        this.verbose = verbose;\n    }\n}\nexports.ComputeOptions = ComputeOptions;\nclass Node {\n    constructor(state, move, parent) {\n        this.state = state;\n        this.move = move;\n        this.parent = parent;\n        this.playerToMove = state.getPlayerToMove();\n        this.wins = 0;\n        this.visits = 0;\n        this.moves = state.getMoves();\n        this.uctScore = 0;\n        this.children = [];\n    }\n    hasUntriedMoves() {\n        return this.moves.length > 0;\n    }\n    getUntriedMove() {\n        asserts.assertNotEmpty(this.moves);\n        let index = Math.floor(Math.random() * this.moves.length);\n        return this.moves[index];\n    }\n    getBestChild() {\n        asserts.assertEmpty(this.moves);\n        asserts.assertNotEmpty(this.children);\n        return this.children.reduce((pv, cv) => pv.visits > cv.visits ? pv : cv);\n    }\n    selectChildViaUctScore() {\n        for (let child of this.children) {\n            let winRatio = child.wins / child.visits;\n            let confidence = Math.sqrt(2 * Math.log(this.visits) / child.visits);\n            child.uctScore = winRatio + confidence;\n        }\n        return this.children.reduce((pv, cv) => pv.uctScore > cv.uctScore ? pv : cv);\n    }\n    addChild(move, state) {\n        let newChild = new Node(state, move, this);\n        this.children.push(newChild);\n        let index = this.moves.indexOf(move);\n        this.moves.splice(index, 1);\n        return newChild;\n    }\n    update(result) {\n        switch (result) {\n            case game_model_1.Result.Draw:\n                this.wins += 0.5;\n                break;\n            case game_model_1.Result.Win:\n                this.wins++;\n            default:\n                break;\n        }\n        this.visits++;\n    }\n    hasChildren() {\n        return this.children.length > 0;\n    }\n}\nfunction computeTree(rootState, options) {\n    asserts.assert(options.maxIterations >= 0 || options.maxTime >= 0);\n    const root = new Node(rootState);\n    const startTime = new Date();\n    for (let i = 0; i < options.maxIterations || options.maxTime < 0; i++) {\n        let node = root;\n        let state = rootState;\n        while (!node.hasUntriedMoves() && node.hasChildren()) {\n            node = node.selectChildViaUctScore();\n            state = state.doMove(node.move);\n        }\n        if (node.hasUntriedMoves()) {\n            let move = node.getUntriedMove();\n            state = state.doMove(move);\n            node = node.addChild(move, state);\n        }\n        while (state.hasMoves()) {\n            state = state.doRandomMove();\n        }\n        while (node) {\n            node.update(state.getResult(node.playerToMove));\n            node = node.parent;\n        }\n        if (options.maxTime > 0) {\n            let elapsedTime = (new Date().getTime()) - startTime.getTime();\n            if (elapsedTime >= options.maxTime) {\n                break;\n            }\n        }\n    }\n    return root;\n}\nfunction computeMove(rootState, options) {\n    let moves = rootState.getMoves();\n    if (moves.length == 1) {\n        return moves[0];\n    }\n    console.time('computeTree');\n    let root = computeTree(rootState, options);\n    console.timeEnd('computeTree');\n    let gamesPlayed = root.visits;\n    console.log(`${gamesPlayed} games played`);\n    let bestScore = -1;\n    let bestMove;\n    for (let node of root.children) {\n        let expectedSuccessRate = (node.wins + 1) / (node.visits + 2);\n        if (expectedSuccessRate > bestScore) {\n            bestMove = node.move;\n            bestScore = expectedSuccessRate;\n        }\n    }\n    console.log(`${bestScore} is the best score`);\n    return bestMove;\n}\nexports.computeMove = computeMove;\n","\"use strict\";\nconst asserts = require('./assert');\nconst game_model_1 = require('./game-model');\nconst collections_1 = require('./collections');\nconst C = 1.44;\nfunction getRandomInteger(upperBounds) {\n    return Math.floor(Math.random() * upperBounds);\n}\nclass Node {\n    constructor(parent, state, move) {\n        this.parent = parent;\n        this.state = state;\n        this.move = move;\n        this.children = [];\n        this.wins = 0;\n        this.visits = 0;\n        this.uctScore = 0;\n        this.confidence = 0;\n        this.validMoves = new collections_1.List(state.getMoves());\n        this.isTerminal = this.validMoves.getSize() == 0;\n    }\n    get isfullyExpanded() {\n        return this.validMoves.getSize() == 0;\n    }\n    getUntriedMove() {\n        let index = getRandomInteger(this.validMoves.getSize());\n        let move = this.validMoves.item(index);\n        this.validMoves.delete(move);\n        return move;\n    }\n    addChild(child) {\n        this.children.push(child);\n    }\n}\nclass UctSearchService {\n    constructor() {\n    }\n    search(rootState, maxIterations = 1000, maxTime = 1000) {\n        let root = new Node(null, rootState);\n        let startTime = Date.now();\n        let i;\n        for (i = 0; i < maxIterations; i++) {\n            let current = this.treePolicy(root, rootState);\n            let reward = this.defaultPolicy(current.state);\n            this.backup(current, reward);\n            if (Date.now() - startTime > maxTime) {\n                break;\n            }\n        }\n        let bestChild = this.bestChild(root, 0);\n        return {\n            move: bestChild.move,\n            winProbabilty: (bestChild.wins / bestChild.visits),\n            time: Date.now() - startTime,\n            iterations: i\n        };\n    }\n    treePolicy(node, state) {\n        while (!node.isTerminal) {\n            if (!node.isfullyExpanded) {\n                return this.expand(node);\n            }\n            else {\n                return this.bestChild(node, C);\n            }\n        }\n    }\n    expand(node) {\n        let a = node.getUntriedMove();\n        let newState = node.state.doMove(a);\n        let newNode = new Node(node, newState, a);\n        node.addChild(newNode);\n        return newNode;\n    }\n    defaultPolicy(state) {\n        let moves = state.getMoves();\n        while (moves.length > 0) {\n            let index = getRandomInteger(moves.length);\n            let move = moves[index];\n            state = state.doMove(move);\n            moves = state.getMoves();\n        }\n        asserts.assert(!state.hasMoves());\n        return (node, player) => {\n            let result = state.getResult(player);\n            switch (result) {\n                case game_model_1.Result.Draw:\n                    return 0.5;\n                case game_model_1.Result.Win:\n                    return 1;\n                default:\n                    return 0;\n            }\n        };\n    }\n    backup(node, reward) {\n        while (node) {\n            let player = node.state.getOpponent(node.state.getPlayerToMove());\n            node.visits++;\n            node.wins += reward(node, player);\n            node = node.parent;\n        }\n    }\n    bestChild(node, c) {\n        node.children.forEach(child => {\n            child.confidence = c * Math.sqrt(2 * Math.log(node.visits) / child.visits);\n            child.uctScore = (child.wins / child.visits) + child.confidence;\n        });\n        return collections_1.Arrays.max(node.children, (a, b) => a.uctScore > b.uctScore);\n    }\n}\nexports.UctSearchService = UctSearchService;\nexports.UctSearchModule = angular.module('UctSearchModule', [])\n    .service('uctSearchService', UctSearchService);\n"]}